// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: base.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_base_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_base_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_base_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_base_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_base_2eproto;
namespace Speechpro {
namespace Cloud {
namespace ASR {
class DictorInfo;
class DictorInfoDefaultTypeInternal;
extern DictorInfoDefaultTypeInternal _DictorInfo_default_instance_;
class Finish;
class FinishDefaultTypeInternal;
extern FinishDefaultTypeInternal _Finish_default_instance_;
class ListOfModels;
class ListOfModelsDefaultTypeInternal;
extern ListOfModelsDefaultTypeInternal _ListOfModels_default_instance_;
class Model;
class ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class Sound;
class SoundDefaultTypeInternal;
extern SoundDefaultTypeInternal _Sound_default_instance_;
class Text;
class TextDefaultTypeInternal;
extern TextDefaultTypeInternal _Text_default_instance_;
class Word;
class WordDefaultTypeInternal;
extern WordDefaultTypeInternal _Word_default_instance_;
}  // namespace ASR
}  // namespace Cloud
}  // namespace Speechpro
PROTOBUF_NAMESPACE_OPEN
template<> ::Speechpro::Cloud::ASR::DictorInfo* Arena::CreateMaybeMessage<::Speechpro::Cloud::ASR::DictorInfo>(Arena*);
template<> ::Speechpro::Cloud::ASR::Finish* Arena::CreateMaybeMessage<::Speechpro::Cloud::ASR::Finish>(Arena*);
template<> ::Speechpro::Cloud::ASR::ListOfModels* Arena::CreateMaybeMessage<::Speechpro::Cloud::ASR::ListOfModels>(Arena*);
template<> ::Speechpro::Cloud::ASR::Model* Arena::CreateMaybeMessage<::Speechpro::Cloud::ASR::Model>(Arena*);
template<> ::Speechpro::Cloud::ASR::Sound* Arena::CreateMaybeMessage<::Speechpro::Cloud::ASR::Sound>(Arena*);
template<> ::Speechpro::Cloud::ASR::Text* Arena::CreateMaybeMessage<::Speechpro::Cloud::ASR::Text>(Arena*);
template<> ::Speechpro::Cloud::ASR::Word* Arena::CreateMaybeMessage<::Speechpro::Cloud::ASR::Word>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Speechpro {
namespace Cloud {
namespace ASR {

enum Word_PunctuationMark : int {
  Word_PunctuationMark_NONE = 0,
  Word_PunctuationMark_DOT = 1,
  Word_PunctuationMark_COMMA = 2,
  Word_PunctuationMark_COLON = 3,
  Word_PunctuationMark_SEMICOLON = 4,
  Word_PunctuationMark_EXCLAMATION_POINT = 5,
  Word_PunctuationMark_QUESTION_MARK = 6,
  Word_PunctuationMark_DASH = 7,
  Word_PunctuationMark_SPEAKER_CHANGE = 8,
  Word_PunctuationMark_Word_PunctuationMark_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Word_PunctuationMark_Word_PunctuationMark_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Word_PunctuationMark_IsValid(int value);
constexpr Word_PunctuationMark Word_PunctuationMark_PunctuationMark_MIN = Word_PunctuationMark_NONE;
constexpr Word_PunctuationMark Word_PunctuationMark_PunctuationMark_MAX = Word_PunctuationMark_SPEAKER_CHANGE;
constexpr int Word_PunctuationMark_PunctuationMark_ARRAYSIZE = Word_PunctuationMark_PunctuationMark_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Word_PunctuationMark_descriptor();
template<typename T>
inline const std::string& Word_PunctuationMark_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Word_PunctuationMark>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Word_PunctuationMark_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Word_PunctuationMark_descriptor(), enum_t_value);
}
inline bool Word_PunctuationMark_Parse(
    const std::string& name, Word_PunctuationMark* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Word_PunctuationMark>(
    Word_PunctuationMark_descriptor(), name, value);
}
enum DictorInfo_DictorNotDetected : int {
  DictorInfo_DictorNotDetected_UNKNOWN_DICTOR = 0,
  DictorInfo_DictorNotDetected_DictorInfo_DictorNotDetected_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DictorInfo_DictorNotDetected_DictorInfo_DictorNotDetected_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DictorInfo_DictorNotDetected_IsValid(int value);
constexpr DictorInfo_DictorNotDetected DictorInfo_DictorNotDetected_DictorNotDetected_MIN = DictorInfo_DictorNotDetected_UNKNOWN_DICTOR;
constexpr DictorInfo_DictorNotDetected DictorInfo_DictorNotDetected_DictorNotDetected_MAX = DictorInfo_DictorNotDetected_UNKNOWN_DICTOR;
constexpr int DictorInfo_DictorNotDetected_DictorNotDetected_ARRAYSIZE = DictorInfo_DictorNotDetected_DictorNotDetected_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DictorInfo_DictorNotDetected_descriptor();
template<typename T>
inline const std::string& DictorInfo_DictorNotDetected_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DictorInfo_DictorNotDetected>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DictorInfo_DictorNotDetected_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DictorInfo_DictorNotDetected_descriptor(), enum_t_value);
}
inline bool DictorInfo_DictorNotDetected_Parse(
    const std::string& name, DictorInfo_DictorNotDetected* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DictorInfo_DictorNotDetected>(
    DictorInfo_DictorNotDetected_descriptor(), name, value);
}
// ===================================================================

class Model :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Speechpro.Cloud.ASR.Model) */ {
 public:
  Model();
  virtual ~Model();

  Model(const Model& from);
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Model& operator=(Model&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Model& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Model* other);
  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Model* New() const final {
    return CreateMaybeMessage<Model>(nullptr);
  }

  Model* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Speechpro.Cloud.ASR.Model";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_base_2eproto);
    return ::descriptor_table_base_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);

  // uint64 active_sessions = 2;
  void clear_active_sessions();
  static const int kActiveSessionsFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint64 active_sessions() const;
  void set_active_sessions(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:Speechpro.Cloud.ASR.Model)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 active_sessions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_base_2eproto;
};
// -------------------------------------------------------------------

class ListOfModels :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Speechpro.Cloud.ASR.ListOfModels) */ {
 public:
  ListOfModels();
  virtual ~ListOfModels();

  ListOfModels(const ListOfModels& from);
  ListOfModels(ListOfModels&& from) noexcept
    : ListOfModels() {
    *this = ::std::move(from);
  }

  inline ListOfModels& operator=(const ListOfModels& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListOfModels& operator=(ListOfModels&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListOfModels& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListOfModels* internal_default_instance() {
    return reinterpret_cast<const ListOfModels*>(
               &_ListOfModels_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ListOfModels* other);
  friend void swap(ListOfModels& a, ListOfModels& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListOfModels* New() const final {
    return CreateMaybeMessage<ListOfModels>(nullptr);
  }

  ListOfModels* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListOfModels>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListOfModels& from);
  void MergeFrom(const ListOfModels& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListOfModels* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Speechpro.Cloud.ASR.ListOfModels";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_base_2eproto);
    return ::descriptor_table_base_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Speechpro.Cloud.ASR.Model models = 1;
  int models_size() const;
  void clear_models();
  static const int kModelsFieldNumber = 1;
  ::Speechpro::Cloud::ASR::Model* mutable_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Speechpro::Cloud::ASR::Model >*
      mutable_models();
  const ::Speechpro::Cloud::ASR::Model& models(int index) const;
  ::Speechpro::Cloud::ASR::Model* add_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Speechpro::Cloud::ASR::Model >&
      models() const;

  // @@protoc_insertion_point(class_scope:Speechpro.Cloud.ASR.ListOfModels)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Speechpro::Cloud::ASR::Model > models_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_base_2eproto;
};
// -------------------------------------------------------------------

class Finish :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Speechpro.Cloud.ASR.Finish) */ {
 public:
  Finish();
  virtual ~Finish();

  Finish(const Finish& from);
  Finish(Finish&& from) noexcept
    : Finish() {
    *this = ::std::move(from);
  }

  inline Finish& operator=(const Finish& from) {
    CopyFrom(from);
    return *this;
  }
  inline Finish& operator=(Finish&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Finish& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Finish* internal_default_instance() {
    return reinterpret_cast<const Finish*>(
               &_Finish_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Finish* other);
  friend void swap(Finish& a, Finish& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Finish* New() const final {
    return CreateMaybeMessage<Finish>(nullptr);
  }

  Finish* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Finish>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Finish& from);
  void MergeFrom(const Finish& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Finish* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Speechpro.Cloud.ASR.Finish";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_base_2eproto);
    return ::descriptor_table_base_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Speechpro.Cloud.ASR.Finish)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_base_2eproto;
};
// -------------------------------------------------------------------

class Text :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Speechpro.Cloud.ASR.Text) */ {
 public:
  Text();
  virtual ~Text();

  Text(const Text& from);
  Text(Text&& from) noexcept
    : Text() {
    *this = ::std::move(from);
  }

  inline Text& operator=(const Text& from) {
    CopyFrom(from);
    return *this;
  }
  inline Text& operator=(Text&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Text& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Text* internal_default_instance() {
    return reinterpret_cast<const Text*>(
               &_Text_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Text* other);
  friend void swap(Text& a, Text& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Text* New() const final {
    return CreateMaybeMessage<Text>(nullptr);
  }

  Text* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Text>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Text& from);
  void MergeFrom(const Text& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Text* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Speechpro.Cloud.ASR.Text";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_base_2eproto);
    return ::descriptor_table_base_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Speechpro.Cloud.ASR.Word words = 1;
  int words_size() const;
  void clear_words();
  static const int kWordsFieldNumber = 1;
  ::Speechpro::Cloud::ASR::Word* mutable_words(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Speechpro::Cloud::ASR::Word >*
      mutable_words();
  const ::Speechpro::Cloud::ASR::Word& words(int index) const;
  ::Speechpro::Cloud::ASR::Word* add_words();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Speechpro::Cloud::ASR::Word >&
      words() const;

  // @@protoc_insertion_point(class_scope:Speechpro.Cloud.ASR.Text)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Speechpro::Cloud::ASR::Word > words_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_base_2eproto;
};
// -------------------------------------------------------------------

class Word :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Speechpro.Cloud.ASR.Word) */ {
 public:
  Word();
  virtual ~Word();

  Word(const Word& from);
  Word(Word&& from) noexcept
    : Word() {
    *this = ::std::move(from);
  }

  inline Word& operator=(const Word& from) {
    CopyFrom(from);
    return *this;
  }
  inline Word& operator=(Word&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Word& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Word* internal_default_instance() {
    return reinterpret_cast<const Word*>(
               &_Word_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Word* other);
  friend void swap(Word& a, Word& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Word* New() const final {
    return CreateMaybeMessage<Word>(nullptr);
  }

  Word* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Word>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Word& from);
  void MergeFrom(const Word& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Word* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Speechpro.Cloud.ASR.Word";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_base_2eproto);
    return ::descriptor_table_base_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Word_PunctuationMark PunctuationMark;
  static constexpr PunctuationMark NONE =
    Word_PunctuationMark_NONE;
  static constexpr PunctuationMark DOT =
    Word_PunctuationMark_DOT;
  static constexpr PunctuationMark COMMA =
    Word_PunctuationMark_COMMA;
  static constexpr PunctuationMark COLON =
    Word_PunctuationMark_COLON;
  static constexpr PunctuationMark SEMICOLON =
    Word_PunctuationMark_SEMICOLON;
  static constexpr PunctuationMark EXCLAMATION_POINT =
    Word_PunctuationMark_EXCLAMATION_POINT;
  static constexpr PunctuationMark QUESTION_MARK =
    Word_PunctuationMark_QUESTION_MARK;
  static constexpr PunctuationMark DASH =
    Word_PunctuationMark_DASH;
  static constexpr PunctuationMark SPEAKER_CHANGE =
    Word_PunctuationMark_SPEAKER_CHANGE;
  static inline bool PunctuationMark_IsValid(int value) {
    return Word_PunctuationMark_IsValid(value);
  }
  static constexpr PunctuationMark PunctuationMark_MIN =
    Word_PunctuationMark_PunctuationMark_MIN;
  static constexpr PunctuationMark PunctuationMark_MAX =
    Word_PunctuationMark_PunctuationMark_MAX;
  static constexpr int PunctuationMark_ARRAYSIZE =
    Word_PunctuationMark_PunctuationMark_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PunctuationMark_descriptor() {
    return Word_PunctuationMark_descriptor();
  }
  template<typename T>
  static inline const std::string& PunctuationMark_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PunctuationMark>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PunctuationMark_Name.");
    return Word_PunctuationMark_Name(enum_t_value);
  }
  static inline bool PunctuationMark_Parse(const std::string& name,
      PunctuationMark* value) {
    return Word_PunctuationMark_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string text = 1;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);

  // .Speechpro.Cloud.ASR.DictorInfo dictor = 6;
  bool has_dictor() const;
  void clear_dictor();
  static const int kDictorFieldNumber = 6;
  const ::Speechpro::Cloud::ASR::DictorInfo& dictor() const;
  ::Speechpro::Cloud::ASR::DictorInfo* release_dictor();
  ::Speechpro::Cloud::ASR::DictorInfo* mutable_dictor();
  void set_allocated_dictor(::Speechpro::Cloud::ASR::DictorInfo* dictor);

  // int64 start_ms = 2;
  void clear_start_ms();
  static const int kStartMsFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int64 start_ms() const;
  void set_start_ms(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int64 length_ms = 3;
  void clear_length_ms();
  static const int kLengthMsFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int64 length_ms() const;
  void set_length_ms(::PROTOBUF_NAMESPACE_ID::int64 value);

  // float confidence = 4;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 4;
  float confidence() const;
  void set_confidence(float value);

  // .Speechpro.Cloud.ASR.Word.PunctuationMark punctuation_mark = 5;
  void clear_punctuation_mark();
  static const int kPunctuationMarkFieldNumber = 5;
  ::Speechpro::Cloud::ASR::Word_PunctuationMark punctuation_mark() const;
  void set_punctuation_mark(::Speechpro::Cloud::ASR::Word_PunctuationMark value);

  // @@protoc_insertion_point(class_scope:Speechpro.Cloud.ASR.Word)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::Speechpro::Cloud::ASR::DictorInfo* dictor_;
  ::PROTOBUF_NAMESPACE_ID::int64 start_ms_;
  ::PROTOBUF_NAMESPACE_ID::int64 length_ms_;
  float confidence_;
  int punctuation_mark_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_base_2eproto;
};
// -------------------------------------------------------------------

class DictorInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Speechpro.Cloud.ASR.DictorInfo) */ {
 public:
  DictorInfo();
  virtual ~DictorInfo();

  DictorInfo(const DictorInfo& from);
  DictorInfo(DictorInfo&& from) noexcept
    : DictorInfo() {
    *this = ::std::move(from);
  }

  inline DictorInfo& operator=(const DictorInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DictorInfo& operator=(DictorInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DictorInfo& default_instance();

  enum DictorInfoCase {
    kDictorNotDetected = 1,
    kDictorNum = 2,
    DICTOR_INFO_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DictorInfo* internal_default_instance() {
    return reinterpret_cast<const DictorInfo*>(
               &_DictorInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(DictorInfo* other);
  friend void swap(DictorInfo& a, DictorInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DictorInfo* New() const final {
    return CreateMaybeMessage<DictorInfo>(nullptr);
  }

  DictorInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DictorInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DictorInfo& from);
  void MergeFrom(const DictorInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DictorInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Speechpro.Cloud.ASR.DictorInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_base_2eproto);
    return ::descriptor_table_base_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef DictorInfo_DictorNotDetected DictorNotDetected;
  static constexpr DictorNotDetected UNKNOWN_DICTOR =
    DictorInfo_DictorNotDetected_UNKNOWN_DICTOR;
  static inline bool DictorNotDetected_IsValid(int value) {
    return DictorInfo_DictorNotDetected_IsValid(value);
  }
  static constexpr DictorNotDetected DictorNotDetected_MIN =
    DictorInfo_DictorNotDetected_DictorNotDetected_MIN;
  static constexpr DictorNotDetected DictorNotDetected_MAX =
    DictorInfo_DictorNotDetected_DictorNotDetected_MAX;
  static constexpr int DictorNotDetected_ARRAYSIZE =
    DictorInfo_DictorNotDetected_DictorNotDetected_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DictorNotDetected_descriptor() {
    return DictorInfo_DictorNotDetected_descriptor();
  }
  template<typename T>
  static inline const std::string& DictorNotDetected_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DictorNotDetected>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DictorNotDetected_Name.");
    return DictorInfo_DictorNotDetected_Name(enum_t_value);
  }
  static inline bool DictorNotDetected_Parse(const std::string& name,
      DictorNotDetected* value) {
    return DictorInfo_DictorNotDetected_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .Speechpro.Cloud.ASR.DictorInfo.DictorNotDetected dictor_not_detected = 1;
  private:
  bool has_dictor_not_detected() const;
  public:
  void clear_dictor_not_detected();
  static const int kDictorNotDetectedFieldNumber = 1;
  ::Speechpro::Cloud::ASR::DictorInfo_DictorNotDetected dictor_not_detected() const;
  void set_dictor_not_detected(::Speechpro::Cloud::ASR::DictorInfo_DictorNotDetected value);

  // int32 dictor_num = 2;
  private:
  bool has_dictor_num() const;
  public:
  void clear_dictor_num();
  static const int kDictorNumFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 dictor_num() const;
  void set_dictor_num(::PROTOBUF_NAMESPACE_ID::int32 value);

  void clear_dictor_info();
  DictorInfoCase dictor_info_case() const;
  // @@protoc_insertion_point(class_scope:Speechpro.Cloud.ASR.DictorInfo)
 private:
  class HasBitSetters;
  void set_has_dictor_not_detected();
  void set_has_dictor_num();

  inline bool has_dictor_info() const;
  inline void clear_has_dictor_info();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union DictorInfoUnion {
    DictorInfoUnion() {}
    int dictor_not_detected_;
    ::PROTOBUF_NAMESPACE_ID::int32 dictor_num_;
  } dictor_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_base_2eproto;
};
// -------------------------------------------------------------------

class Sound :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Speechpro.Cloud.ASR.Sound) */ {
 public:
  Sound();
  virtual ~Sound();

  Sound(const Sound& from);
  Sound(Sound&& from) noexcept
    : Sound() {
    *this = ::std::move(from);
  }

  inline Sound& operator=(const Sound& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sound& operator=(Sound&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Sound& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sound* internal_default_instance() {
    return reinterpret_cast<const Sound*>(
               &_Sound_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Sound* other);
  friend void swap(Sound& a, Sound& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sound* New() const final {
    return CreateMaybeMessage<Sound>(nullptr);
  }

  Sound* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Sound>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Sound& from);
  void MergeFrom(const Sound& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sound* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Speechpro.Cloud.ASR.Sound";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_base_2eproto);
    return ::descriptor_table_base_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes samples = 1;
  void clear_samples();
  static const int kSamplesFieldNumber = 1;
  const std::string& samples() const;
  void set_samples(const std::string& value);
  void set_samples(std::string&& value);
  void set_samples(const char* value);
  void set_samples(const void* value, size_t size);
  std::string* mutable_samples();
  std::string* release_samples();
  void set_allocated_samples(std::string* samples);

  // @@protoc_insertion_point(class_scope:Speechpro.Cloud.ASR.Sound)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr samples_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_base_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Model

// string id = 1;
inline void Model::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Model::id() const {
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.Model.id)
  return id_.GetNoArena();
}
inline void Model::set_id(const std::string& value) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Speechpro.Cloud.ASR.Model.id)
}
inline void Model::set_id(std::string&& value) {
  
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Speechpro.Cloud.ASR.Model.id)
}
inline void Model::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Speechpro.Cloud.ASR.Model.id)
}
inline void Model::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Speechpro.Cloud.ASR.Model.id)
}
inline std::string* Model::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:Speechpro.Cloud.ASR.Model.id)
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Model::release_id() {
  // @@protoc_insertion_point(field_release:Speechpro.Cloud.ASR.Model.id)
  
  return id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Model::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:Speechpro.Cloud.ASR.Model.id)
}

// uint64 active_sessions = 2;
inline void Model::clear_active_sessions() {
  active_sessions_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Model::active_sessions() const {
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.Model.active_sessions)
  return active_sessions_;
}
inline void Model::set_active_sessions(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  active_sessions_ = value;
  // @@protoc_insertion_point(field_set:Speechpro.Cloud.ASR.Model.active_sessions)
}

// -------------------------------------------------------------------

// ListOfModels

// repeated .Speechpro.Cloud.ASR.Model models = 1;
inline int ListOfModels::models_size() const {
  return models_.size();
}
inline void ListOfModels::clear_models() {
  models_.Clear();
}
inline ::Speechpro::Cloud::ASR::Model* ListOfModels::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:Speechpro.Cloud.ASR.ListOfModels.models)
  return models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Speechpro::Cloud::ASR::Model >*
ListOfModels::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:Speechpro.Cloud.ASR.ListOfModels.models)
  return &models_;
}
inline const ::Speechpro::Cloud::ASR::Model& ListOfModels::models(int index) const {
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.ListOfModels.models)
  return models_.Get(index);
}
inline ::Speechpro::Cloud::ASR::Model* ListOfModels::add_models() {
  // @@protoc_insertion_point(field_add:Speechpro.Cloud.ASR.ListOfModels.models)
  return models_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Speechpro::Cloud::ASR::Model >&
ListOfModels::models() const {
  // @@protoc_insertion_point(field_list:Speechpro.Cloud.ASR.ListOfModels.models)
  return models_;
}

// -------------------------------------------------------------------

// Finish

// -------------------------------------------------------------------

// Text

// repeated .Speechpro.Cloud.ASR.Word words = 1;
inline int Text::words_size() const {
  return words_.size();
}
inline void Text::clear_words() {
  words_.Clear();
}
inline ::Speechpro::Cloud::ASR::Word* Text::mutable_words(int index) {
  // @@protoc_insertion_point(field_mutable:Speechpro.Cloud.ASR.Text.words)
  return words_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Speechpro::Cloud::ASR::Word >*
Text::mutable_words() {
  // @@protoc_insertion_point(field_mutable_list:Speechpro.Cloud.ASR.Text.words)
  return &words_;
}
inline const ::Speechpro::Cloud::ASR::Word& Text::words(int index) const {
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.Text.words)
  return words_.Get(index);
}
inline ::Speechpro::Cloud::ASR::Word* Text::add_words() {
  // @@protoc_insertion_point(field_add:Speechpro.Cloud.ASR.Text.words)
  return words_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Speechpro::Cloud::ASR::Word >&
Text::words() const {
  // @@protoc_insertion_point(field_list:Speechpro.Cloud.ASR.Text.words)
  return words_;
}

// -------------------------------------------------------------------

// Word

// string text = 1;
inline void Word::clear_text() {
  text_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Word::text() const {
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.Word.text)
  return text_.GetNoArena();
}
inline void Word::set_text(const std::string& value) {
  
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Speechpro.Cloud.ASR.Word.text)
}
inline void Word::set_text(std::string&& value) {
  
  text_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Speechpro.Cloud.ASR.Word.text)
}
inline void Word::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Speechpro.Cloud.ASR.Word.text)
}
inline void Word::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Speechpro.Cloud.ASR.Word.text)
}
inline std::string* Word::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:Speechpro.Cloud.ASR.Word.text)
  return text_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Word::release_text() {
  // @@protoc_insertion_point(field_release:Speechpro.Cloud.ASR.Word.text)
  
  return text_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Word::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:Speechpro.Cloud.ASR.Word.text)
}

// int64 start_ms = 2;
inline void Word::clear_start_ms() {
  start_ms_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Word::start_ms() const {
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.Word.start_ms)
  return start_ms_;
}
inline void Word::set_start_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  start_ms_ = value;
  // @@protoc_insertion_point(field_set:Speechpro.Cloud.ASR.Word.start_ms)
}

// int64 length_ms = 3;
inline void Word::clear_length_ms() {
  length_ms_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Word::length_ms() const {
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.Word.length_ms)
  return length_ms_;
}
inline void Word::set_length_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  length_ms_ = value;
  // @@protoc_insertion_point(field_set:Speechpro.Cloud.ASR.Word.length_ms)
}

// float confidence = 4;
inline void Word::clear_confidence() {
  confidence_ = 0;
}
inline float Word::confidence() const {
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.Word.confidence)
  return confidence_;
}
inline void Word::set_confidence(float value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:Speechpro.Cloud.ASR.Word.confidence)
}

// .Speechpro.Cloud.ASR.Word.PunctuationMark punctuation_mark = 5;
inline void Word::clear_punctuation_mark() {
  punctuation_mark_ = 0;
}
inline ::Speechpro::Cloud::ASR::Word_PunctuationMark Word::punctuation_mark() const {
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.Word.punctuation_mark)
  return static_cast< ::Speechpro::Cloud::ASR::Word_PunctuationMark >(punctuation_mark_);
}
inline void Word::set_punctuation_mark(::Speechpro::Cloud::ASR::Word_PunctuationMark value) {
  
  punctuation_mark_ = value;
  // @@protoc_insertion_point(field_set:Speechpro.Cloud.ASR.Word.punctuation_mark)
}

// .Speechpro.Cloud.ASR.DictorInfo dictor = 6;
inline bool Word::has_dictor() const {
  return this != internal_default_instance() && dictor_ != nullptr;
}
inline void Word::clear_dictor() {
  if (GetArenaNoVirtual() == nullptr && dictor_ != nullptr) {
    delete dictor_;
  }
  dictor_ = nullptr;
}
inline const ::Speechpro::Cloud::ASR::DictorInfo& Word::dictor() const {
  const ::Speechpro::Cloud::ASR::DictorInfo* p = dictor_;
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.Word.dictor)
  return p != nullptr ? *p : *reinterpret_cast<const ::Speechpro::Cloud::ASR::DictorInfo*>(
      &::Speechpro::Cloud::ASR::_DictorInfo_default_instance_);
}
inline ::Speechpro::Cloud::ASR::DictorInfo* Word::release_dictor() {
  // @@protoc_insertion_point(field_release:Speechpro.Cloud.ASR.Word.dictor)
  
  ::Speechpro::Cloud::ASR::DictorInfo* temp = dictor_;
  dictor_ = nullptr;
  return temp;
}
inline ::Speechpro::Cloud::ASR::DictorInfo* Word::mutable_dictor() {
  
  if (dictor_ == nullptr) {
    auto* p = CreateMaybeMessage<::Speechpro::Cloud::ASR::DictorInfo>(GetArenaNoVirtual());
    dictor_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Speechpro.Cloud.ASR.Word.dictor)
  return dictor_;
}
inline void Word::set_allocated_dictor(::Speechpro::Cloud::ASR::DictorInfo* dictor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dictor_;
  }
  if (dictor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dictor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dictor, submessage_arena);
    }
    
  } else {
    
  }
  dictor_ = dictor;
  // @@protoc_insertion_point(field_set_allocated:Speechpro.Cloud.ASR.Word.dictor)
}

// -------------------------------------------------------------------

// DictorInfo

// .Speechpro.Cloud.ASR.DictorInfo.DictorNotDetected dictor_not_detected = 1;
inline bool DictorInfo::has_dictor_not_detected() const {
  return dictor_info_case() == kDictorNotDetected;
}
inline void DictorInfo::set_has_dictor_not_detected() {
  _oneof_case_[0] = kDictorNotDetected;
}
inline void DictorInfo::clear_dictor_not_detected() {
  if (has_dictor_not_detected()) {
    dictor_info_.dictor_not_detected_ = 0;
    clear_has_dictor_info();
  }
}
inline ::Speechpro::Cloud::ASR::DictorInfo_DictorNotDetected DictorInfo::dictor_not_detected() const {
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.DictorInfo.dictor_not_detected)
  if (has_dictor_not_detected()) {
    return static_cast< ::Speechpro::Cloud::ASR::DictorInfo_DictorNotDetected >(dictor_info_.dictor_not_detected_);
  }
  return static_cast< ::Speechpro::Cloud::ASR::DictorInfo_DictorNotDetected >(0);
}
inline void DictorInfo::set_dictor_not_detected(::Speechpro::Cloud::ASR::DictorInfo_DictorNotDetected value) {
  if (!has_dictor_not_detected()) {
    clear_dictor_info();
    set_has_dictor_not_detected();
  }
  dictor_info_.dictor_not_detected_ = value;
  // @@protoc_insertion_point(field_set:Speechpro.Cloud.ASR.DictorInfo.dictor_not_detected)
}

// int32 dictor_num = 2;
inline bool DictorInfo::has_dictor_num() const {
  return dictor_info_case() == kDictorNum;
}
inline void DictorInfo::set_has_dictor_num() {
  _oneof_case_[0] = kDictorNum;
}
inline void DictorInfo::clear_dictor_num() {
  if (has_dictor_num()) {
    dictor_info_.dictor_num_ = 0;
    clear_has_dictor_info();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DictorInfo::dictor_num() const {
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.DictorInfo.dictor_num)
  if (has_dictor_num()) {
    return dictor_info_.dictor_num_;
  }
  return 0;
}
inline void DictorInfo::set_dictor_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  if (!has_dictor_num()) {
    clear_dictor_info();
    set_has_dictor_num();
  }
  dictor_info_.dictor_num_ = value;
  // @@protoc_insertion_point(field_set:Speechpro.Cloud.ASR.DictorInfo.dictor_num)
}

inline bool DictorInfo::has_dictor_info() const {
  return dictor_info_case() != DICTOR_INFO_NOT_SET;
}
inline void DictorInfo::clear_has_dictor_info() {
  _oneof_case_[0] = DICTOR_INFO_NOT_SET;
}
inline DictorInfo::DictorInfoCase DictorInfo::dictor_info_case() const {
  return DictorInfo::DictorInfoCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Sound

// bytes samples = 1;
inline void Sound::clear_samples() {
  samples_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Sound::samples() const {
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.Sound.samples)
  return samples_.GetNoArena();
}
inline void Sound::set_samples(const std::string& value) {
  
  samples_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Speechpro.Cloud.ASR.Sound.samples)
}
inline void Sound::set_samples(std::string&& value) {
  
  samples_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Speechpro.Cloud.ASR.Sound.samples)
}
inline void Sound::set_samples(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  samples_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Speechpro.Cloud.ASR.Sound.samples)
}
inline void Sound::set_samples(const void* value, size_t size) {
  
  samples_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Speechpro.Cloud.ASR.Sound.samples)
}
inline std::string* Sound::mutable_samples() {
  
  // @@protoc_insertion_point(field_mutable:Speechpro.Cloud.ASR.Sound.samples)
  return samples_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Sound::release_samples() {
  // @@protoc_insertion_point(field_release:Speechpro.Cloud.ASR.Sound.samples)
  
  return samples_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Sound::set_allocated_samples(std::string* samples) {
  if (samples != nullptr) {
    
  } else {
    
  }
  samples_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), samples);
  // @@protoc_insertion_point(field_set_allocated:Speechpro.Cloud.ASR.Sound.samples)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ASR
}  // namespace Cloud
}  // namespace Speechpro

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Speechpro::Cloud::ASR::Word_PunctuationMark> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Speechpro::Cloud::ASR::Word_PunctuationMark>() {
  return ::Speechpro::Cloud::ASR::Word_PunctuationMark_descriptor();
}
template <> struct is_proto_enum< ::Speechpro::Cloud::ASR::DictorInfo_DictorNotDetected> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Speechpro::Cloud::ASR::DictorInfo_DictorNotDetected>() {
  return ::Speechpro::Cloud::ASR::DictorInfo_DictorNotDetected_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_base_2eproto
