// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AsrService.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_AsrService_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_AsrService_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "base.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_AsrService_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_AsrService_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_AsrService_2eproto;
namespace Speechpro {
namespace Cloud {
namespace ASR {
class Auth;
class AuthDefaultTypeInternal;
extern AuthDefaultTypeInternal _Auth_default_instance_;
class RecognitionConfig;
class RecognitionConfigDefaultTypeInternal;
extern RecognitionConfigDefaultTypeInternal _RecognitionConfig_default_instance_;
class RecognizeRequest;
class RecognizeRequestDefaultTypeInternal;
extern RecognizeRequestDefaultTypeInternal _RecognizeRequest_default_instance_;
class SpeechRecognitionResults;
class SpeechRecognitionResultsDefaultTypeInternal;
extern SpeechRecognitionResultsDefaultTypeInternal _SpeechRecognitionResults_default_instance_;
class UserTranscriptions;
class UserTranscriptionsDefaultTypeInternal;
extern UserTranscriptionsDefaultTypeInternal _UserTranscriptions_default_instance_;
}  // namespace ASR
}  // namespace Cloud
}  // namespace Speechpro
PROTOBUF_NAMESPACE_OPEN
template<> ::Speechpro::Cloud::ASR::Auth* Arena::CreateMaybeMessage<::Speechpro::Cloud::ASR::Auth>(Arena*);
template<> ::Speechpro::Cloud::ASR::RecognitionConfig* Arena::CreateMaybeMessage<::Speechpro::Cloud::ASR::RecognitionConfig>(Arena*);
template<> ::Speechpro::Cloud::ASR::RecognizeRequest* Arena::CreateMaybeMessage<::Speechpro::Cloud::ASR::RecognizeRequest>(Arena*);
template<> ::Speechpro::Cloud::ASR::SpeechRecognitionResults* Arena::CreateMaybeMessage<::Speechpro::Cloud::ASR::SpeechRecognitionResults>(Arena*);
template<> ::Speechpro::Cloud::ASR::UserTranscriptions* Arena::CreateMaybeMessage<::Speechpro::Cloud::ASR::UserTranscriptions>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Speechpro {
namespace Cloud {
namespace ASR {

// ===================================================================

class RecognizeRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Speechpro.Cloud.ASR.RecognizeRequest) */ {
 public:
  RecognizeRequest();
  virtual ~RecognizeRequest();

  RecognizeRequest(const RecognizeRequest& from);
  RecognizeRequest(RecognizeRequest&& from) noexcept
    : RecognizeRequest() {
    *this = ::std::move(from);
  }

  inline RecognizeRequest& operator=(const RecognizeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecognizeRequest& operator=(RecognizeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RecognizeRequest& default_instance();

  enum RecognizeRequestCase {
    kConfig = 1,
    kSound = 2,
    kFinish = 3,
    RECOGNIZE_REQUEST_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecognizeRequest* internal_default_instance() {
    return reinterpret_cast<const RecognizeRequest*>(
               &_RecognizeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(RecognizeRequest* other);
  friend void swap(RecognizeRequest& a, RecognizeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecognizeRequest* New() const final {
    return CreateMaybeMessage<RecognizeRequest>(nullptr);
  }

  RecognizeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecognizeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RecognizeRequest& from);
  void MergeFrom(const RecognizeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecognizeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Speechpro.Cloud.ASR.RecognizeRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_AsrService_2eproto);
    return ::descriptor_table_AsrService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Speechpro.Cloud.ASR.RecognitionConfig config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  const ::Speechpro::Cloud::ASR::RecognitionConfig& config() const;
  ::Speechpro::Cloud::ASR::RecognitionConfig* release_config();
  ::Speechpro::Cloud::ASR::RecognitionConfig* mutable_config();
  void set_allocated_config(::Speechpro::Cloud::ASR::RecognitionConfig* config);

  // .Speechpro.Cloud.ASR.Sound sound = 2;
  bool has_sound() const;
  void clear_sound();
  static const int kSoundFieldNumber = 2;
  const ::Speechpro::Cloud::ASR::Sound& sound() const;
  ::Speechpro::Cloud::ASR::Sound* release_sound();
  ::Speechpro::Cloud::ASR::Sound* mutable_sound();
  void set_allocated_sound(::Speechpro::Cloud::ASR::Sound* sound);

  // .Speechpro.Cloud.ASR.Finish finish = 3;
  bool has_finish() const;
  void clear_finish();
  static const int kFinishFieldNumber = 3;
  const ::Speechpro::Cloud::ASR::Finish& finish() const;
  ::Speechpro::Cloud::ASR::Finish* release_finish();
  ::Speechpro::Cloud::ASR::Finish* mutable_finish();
  void set_allocated_finish(::Speechpro::Cloud::ASR::Finish* finish);

  void clear_recognize_request();
  RecognizeRequestCase recognize_request_case() const;
  // @@protoc_insertion_point(class_scope:Speechpro.Cloud.ASR.RecognizeRequest)
 private:
  class HasBitSetters;
  void set_has_config();
  void set_has_sound();
  void set_has_finish();

  inline bool has_recognize_request() const;
  inline void clear_has_recognize_request();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union RecognizeRequestUnion {
    RecognizeRequestUnion() {}
    ::Speechpro::Cloud::ASR::RecognitionConfig* config_;
    ::Speechpro::Cloud::ASR::Sound* sound_;
    ::Speechpro::Cloud::ASR::Finish* finish_;
  } recognize_request_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_AsrService_2eproto;
};
// -------------------------------------------------------------------

class RecognitionConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Speechpro.Cloud.ASR.RecognitionConfig) */ {
 public:
  RecognitionConfig();
  virtual ~RecognitionConfig();

  RecognitionConfig(const RecognitionConfig& from);
  RecognitionConfig(RecognitionConfig&& from) noexcept
    : RecognitionConfig() {
    *this = ::std::move(from);
  }

  inline RecognitionConfig& operator=(const RecognitionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecognitionConfig& operator=(RecognitionConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RecognitionConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecognitionConfig* internal_default_instance() {
    return reinterpret_cast<const RecognitionConfig*>(
               &_RecognitionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RecognitionConfig* other);
  friend void swap(RecognitionConfig& a, RecognitionConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecognitionConfig* New() const final {
    return CreateMaybeMessage<RecognitionConfig>(nullptr);
  }

  RecognitionConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecognitionConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RecognitionConfig& from);
  void MergeFrom(const RecognitionConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecognitionConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Speechpro.Cloud.ASR.RecognitionConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_AsrService_2eproto);
    return ::descriptor_table_AsrService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string additional_words = 2;
  int additional_words_size() const;
  void clear_additional_words();
  static const int kAdditionalWordsFieldNumber = 2;
  const std::string& additional_words(int index) const;
  std::string* mutable_additional_words(int index);
  void set_additional_words(int index, const std::string& value);
  void set_additional_words(int index, std::string&& value);
  void set_additional_words(int index, const char* value);
  void set_additional_words(int index, const char* value, size_t size);
  std::string* add_additional_words();
  void add_additional_words(const std::string& value);
  void add_additional_words(std::string&& value);
  void add_additional_words(const char* value);
  void add_additional_words(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& additional_words() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_additional_words();

  // repeated .Speechpro.Cloud.ASR.UserTranscriptions user_transcriptions = 3;
  int user_transcriptions_size() const;
  void clear_user_transcriptions();
  static const int kUserTranscriptionsFieldNumber = 3;
  ::Speechpro::Cloud::ASR::UserTranscriptions* mutable_user_transcriptions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Speechpro::Cloud::ASR::UserTranscriptions >*
      mutable_user_transcriptions();
  const ::Speechpro::Cloud::ASR::UserTranscriptions& user_transcriptions(int index) const;
  ::Speechpro::Cloud::ASR::UserTranscriptions* add_user_transcriptions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Speechpro::Cloud::ASR::UserTranscriptions >&
      user_transcriptions() const;

  // .Speechpro.Cloud.ASR.Model model = 1;
  bool has_model() const;
  void clear_model();
  static const int kModelFieldNumber = 1;
  const ::Speechpro::Cloud::ASR::Model& model() const;
  ::Speechpro::Cloud::ASR::Model* release_model();
  ::Speechpro::Cloud::ASR::Model* mutable_model();
  void set_allocated_model(::Speechpro::Cloud::ASR::Model* model);

  // .Speechpro.Cloud.ASR.Auth auth = 4;
  bool has_auth() const;
  void clear_auth();
  static const int kAuthFieldNumber = 4;
  const ::Speechpro::Cloud::ASR::Auth& auth() const;
  ::Speechpro::Cloud::ASR::Auth* release_auth();
  ::Speechpro::Cloud::ASR::Auth* mutable_auth();
  void set_allocated_auth(::Speechpro::Cloud::ASR::Auth* auth);

  // @@protoc_insertion_point(class_scope:Speechpro.Cloud.ASR.RecognitionConfig)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> additional_words_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Speechpro::Cloud::ASR::UserTranscriptions > user_transcriptions_;
  ::Speechpro::Cloud::ASR::Model* model_;
  ::Speechpro::Cloud::ASR::Auth* auth_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_AsrService_2eproto;
};
// -------------------------------------------------------------------

class Auth :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Speechpro.Cloud.ASR.Auth) */ {
 public:
  Auth();
  virtual ~Auth();

  Auth(const Auth& from);
  Auth(Auth&& from) noexcept
    : Auth() {
    *this = ::std::move(from);
  }

  inline Auth& operator=(const Auth& from) {
    CopyFrom(from);
    return *this;
  }
  inline Auth& operator=(Auth&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Auth& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Auth* internal_default_instance() {
    return reinterpret_cast<const Auth*>(
               &_Auth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Auth* other);
  friend void swap(Auth& a, Auth& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Auth* New() const final {
    return CreateMaybeMessage<Auth>(nullptr);
  }

  Auth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Auth>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Auth& from);
  void MergeFrom(const Auth& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Auth* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Speechpro.Cloud.ASR.Auth";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_AsrService_2eproto);
    return ::descriptor_table_AsrService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string client_id = 1;
  void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  const std::string& client_id() const;
  void set_client_id(const std::string& value);
  void set_client_id(std::string&& value);
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  std::string* mutable_client_id();
  std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);

  // string domain_id = 2;
  void clear_domain_id();
  static const int kDomainIdFieldNumber = 2;
  const std::string& domain_id() const;
  void set_domain_id(const std::string& value);
  void set_domain_id(std::string&& value);
  void set_domain_id(const char* value);
  void set_domain_id(const char* value, size_t size);
  std::string* mutable_domain_id();
  std::string* release_domain_id();
  void set_allocated_domain_id(std::string* domain_id);

  // string api_key = 3;
  void clear_api_key();
  static const int kApiKeyFieldNumber = 3;
  const std::string& api_key() const;
  void set_api_key(const std::string& value);
  void set_api_key(std::string&& value);
  void set_api_key(const char* value);
  void set_api_key(const char* value, size_t size);
  std::string* mutable_api_key();
  std::string* release_api_key();
  void set_allocated_api_key(std::string* api_key);

  // @@protoc_insertion_point(class_scope:Speechpro.Cloud.ASR.Auth)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr api_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_AsrService_2eproto;
};
// -------------------------------------------------------------------

class UserTranscriptions :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Speechpro.Cloud.ASR.UserTranscriptions) */ {
 public:
  UserTranscriptions();
  virtual ~UserTranscriptions();

  UserTranscriptions(const UserTranscriptions& from);
  UserTranscriptions(UserTranscriptions&& from) noexcept
    : UserTranscriptions() {
    *this = ::std::move(from);
  }

  inline UserTranscriptions& operator=(const UserTranscriptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserTranscriptions& operator=(UserTranscriptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UserTranscriptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserTranscriptions* internal_default_instance() {
    return reinterpret_cast<const UserTranscriptions*>(
               &_UserTranscriptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(UserTranscriptions* other);
  friend void swap(UserTranscriptions& a, UserTranscriptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserTranscriptions* New() const final {
    return CreateMaybeMessage<UserTranscriptions>(nullptr);
  }

  UserTranscriptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserTranscriptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserTranscriptions& from);
  void MergeFrom(const UserTranscriptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserTranscriptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Speechpro.Cloud.ASR.UserTranscriptions";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_AsrService_2eproto);
    return ::descriptor_table_AsrService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string word = 1;
  void clear_word();
  static const int kWordFieldNumber = 1;
  const std::string& word() const;
  void set_word(const std::string& value);
  void set_word(std::string&& value);
  void set_word(const char* value);
  void set_word(const char* value, size_t size);
  std::string* mutable_word();
  std::string* release_word();
  void set_allocated_word(std::string* word);

  // string transcription = 2;
  void clear_transcription();
  static const int kTranscriptionFieldNumber = 2;
  const std::string& transcription() const;
  void set_transcription(const std::string& value);
  void set_transcription(std::string&& value);
  void set_transcription(const char* value);
  void set_transcription(const char* value, size_t size);
  std::string* mutable_transcription();
  std::string* release_transcription();
  void set_allocated_transcription(std::string* transcription);

  // @@protoc_insertion_point(class_scope:Speechpro.Cloud.ASR.UserTranscriptions)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr word_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transcription_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_AsrService_2eproto;
};
// -------------------------------------------------------------------

class SpeechRecognitionResults :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Speechpro.Cloud.ASR.SpeechRecognitionResults) */ {
 public:
  SpeechRecognitionResults();
  virtual ~SpeechRecognitionResults();

  SpeechRecognitionResults(const SpeechRecognitionResults& from);
  SpeechRecognitionResults(SpeechRecognitionResults&& from) noexcept
    : SpeechRecognitionResults() {
    *this = ::std::move(from);
  }

  inline SpeechRecognitionResults& operator=(const SpeechRecognitionResults& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeechRecognitionResults& operator=(SpeechRecognitionResults&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpeechRecognitionResults& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpeechRecognitionResults* internal_default_instance() {
    return reinterpret_cast<const SpeechRecognitionResults*>(
               &_SpeechRecognitionResults_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(SpeechRecognitionResults* other);
  friend void swap(SpeechRecognitionResults& a, SpeechRecognitionResults& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpeechRecognitionResults* New() const final {
    return CreateMaybeMessage<SpeechRecognitionResults>(nullptr);
  }

  SpeechRecognitionResults* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpeechRecognitionResults>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpeechRecognitionResults& from);
  void MergeFrom(const SpeechRecognitionResults& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeechRecognitionResults* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Speechpro.Cloud.ASR.SpeechRecognitionResults";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_AsrService_2eproto);
    return ::descriptor_table_AsrService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Speechpro.Cloud.ASR.Text text = 1;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::Speechpro::Cloud::ASR::Text& text() const;
  ::Speechpro::Cloud::ASR::Text* release_text();
  ::Speechpro::Cloud::ASR::Text* mutable_text();
  void set_allocated_text(::Speechpro::Cloud::ASR::Text* text);

  // float phrase_confidence = 2;
  void clear_phrase_confidence();
  static const int kPhraseConfidenceFieldNumber = 2;
  float phrase_confidence() const;
  void set_phrase_confidence(float value);

  // bool is_final = 3;
  void clear_is_final();
  static const int kIsFinalFieldNumber = 3;
  bool is_final() const;
  void set_is_final(bool value);

  // @@protoc_insertion_point(class_scope:Speechpro.Cloud.ASR.SpeechRecognitionResults)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::Speechpro::Cloud::ASR::Text* text_;
  float phrase_confidence_;
  bool is_final_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_AsrService_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RecognizeRequest

// .Speechpro.Cloud.ASR.RecognitionConfig config = 1;
inline bool RecognizeRequest::has_config() const {
  return recognize_request_case() == kConfig;
}
inline void RecognizeRequest::set_has_config() {
  _oneof_case_[0] = kConfig;
}
inline void RecognizeRequest::clear_config() {
  if (has_config()) {
    delete recognize_request_.config_;
    clear_has_recognize_request();
  }
}
inline ::Speechpro::Cloud::ASR::RecognitionConfig* RecognizeRequest::release_config() {
  // @@protoc_insertion_point(field_release:Speechpro.Cloud.ASR.RecognizeRequest.config)
  if (has_config()) {
    clear_has_recognize_request();
      ::Speechpro::Cloud::ASR::RecognitionConfig* temp = recognize_request_.config_;
    recognize_request_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Speechpro::Cloud::ASR::RecognitionConfig& RecognizeRequest::config() const {
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.RecognizeRequest.config)
  return has_config()
      ? *recognize_request_.config_
      : *reinterpret_cast< ::Speechpro::Cloud::ASR::RecognitionConfig*>(&::Speechpro::Cloud::ASR::_RecognitionConfig_default_instance_);
}
inline ::Speechpro::Cloud::ASR::RecognitionConfig* RecognizeRequest::mutable_config() {
  if (!has_config()) {
    clear_recognize_request();
    set_has_config();
    recognize_request_.config_ = CreateMaybeMessage< ::Speechpro::Cloud::ASR::RecognitionConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Speechpro.Cloud.ASR.RecognizeRequest.config)
  return recognize_request_.config_;
}

// .Speechpro.Cloud.ASR.Sound sound = 2;
inline bool RecognizeRequest::has_sound() const {
  return recognize_request_case() == kSound;
}
inline void RecognizeRequest::set_has_sound() {
  _oneof_case_[0] = kSound;
}
inline ::Speechpro::Cloud::ASR::Sound* RecognizeRequest::release_sound() {
  // @@protoc_insertion_point(field_release:Speechpro.Cloud.ASR.RecognizeRequest.sound)
  if (has_sound()) {
    clear_has_recognize_request();
      ::Speechpro::Cloud::ASR::Sound* temp = recognize_request_.sound_;
    recognize_request_.sound_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Speechpro::Cloud::ASR::Sound& RecognizeRequest::sound() const {
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.RecognizeRequest.sound)
  return has_sound()
      ? *recognize_request_.sound_
      : *reinterpret_cast< ::Speechpro::Cloud::ASR::Sound*>(&::Speechpro::Cloud::ASR::_Sound_default_instance_);
}
inline ::Speechpro::Cloud::ASR::Sound* RecognizeRequest::mutable_sound() {
  if (!has_sound()) {
    clear_recognize_request();
    set_has_sound();
    recognize_request_.sound_ = CreateMaybeMessage< ::Speechpro::Cloud::ASR::Sound >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Speechpro.Cloud.ASR.RecognizeRequest.sound)
  return recognize_request_.sound_;
}

// .Speechpro.Cloud.ASR.Finish finish = 3;
inline bool RecognizeRequest::has_finish() const {
  return recognize_request_case() == kFinish;
}
inline void RecognizeRequest::set_has_finish() {
  _oneof_case_[0] = kFinish;
}
inline ::Speechpro::Cloud::ASR::Finish* RecognizeRequest::release_finish() {
  // @@protoc_insertion_point(field_release:Speechpro.Cloud.ASR.RecognizeRequest.finish)
  if (has_finish()) {
    clear_has_recognize_request();
      ::Speechpro::Cloud::ASR::Finish* temp = recognize_request_.finish_;
    recognize_request_.finish_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Speechpro::Cloud::ASR::Finish& RecognizeRequest::finish() const {
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.RecognizeRequest.finish)
  return has_finish()
      ? *recognize_request_.finish_
      : *reinterpret_cast< ::Speechpro::Cloud::ASR::Finish*>(&::Speechpro::Cloud::ASR::_Finish_default_instance_);
}
inline ::Speechpro::Cloud::ASR::Finish* RecognizeRequest::mutable_finish() {
  if (!has_finish()) {
    clear_recognize_request();
    set_has_finish();
    recognize_request_.finish_ = CreateMaybeMessage< ::Speechpro::Cloud::ASR::Finish >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Speechpro.Cloud.ASR.RecognizeRequest.finish)
  return recognize_request_.finish_;
}

inline bool RecognizeRequest::has_recognize_request() const {
  return recognize_request_case() != RECOGNIZE_REQUEST_NOT_SET;
}
inline void RecognizeRequest::clear_has_recognize_request() {
  _oneof_case_[0] = RECOGNIZE_REQUEST_NOT_SET;
}
inline RecognizeRequest::RecognizeRequestCase RecognizeRequest::recognize_request_case() const {
  return RecognizeRequest::RecognizeRequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RecognitionConfig

// .Speechpro.Cloud.ASR.Model model = 1;
inline bool RecognitionConfig::has_model() const {
  return this != internal_default_instance() && model_ != nullptr;
}
inline const ::Speechpro::Cloud::ASR::Model& RecognitionConfig::model() const {
  const ::Speechpro::Cloud::ASR::Model* p = model_;
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.RecognitionConfig.model)
  return p != nullptr ? *p : *reinterpret_cast<const ::Speechpro::Cloud::ASR::Model*>(
      &::Speechpro::Cloud::ASR::_Model_default_instance_);
}
inline ::Speechpro::Cloud::ASR::Model* RecognitionConfig::release_model() {
  // @@protoc_insertion_point(field_release:Speechpro.Cloud.ASR.RecognitionConfig.model)
  
  ::Speechpro::Cloud::ASR::Model* temp = model_;
  model_ = nullptr;
  return temp;
}
inline ::Speechpro::Cloud::ASR::Model* RecognitionConfig::mutable_model() {
  
  if (model_ == nullptr) {
    auto* p = CreateMaybeMessage<::Speechpro::Cloud::ASR::Model>(GetArenaNoVirtual());
    model_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Speechpro.Cloud.ASR.RecognitionConfig.model)
  return model_;
}
inline void RecognitionConfig::set_allocated_model(::Speechpro::Cloud::ASR::Model* model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_);
  }
  if (model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model, submessage_arena);
    }
    
  } else {
    
  }
  model_ = model;
  // @@protoc_insertion_point(field_set_allocated:Speechpro.Cloud.ASR.RecognitionConfig.model)
}

// repeated string additional_words = 2;
inline int RecognitionConfig::additional_words_size() const {
  return additional_words_.size();
}
inline void RecognitionConfig::clear_additional_words() {
  additional_words_.Clear();
}
inline const std::string& RecognitionConfig::additional_words(int index) const {
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.RecognitionConfig.additional_words)
  return additional_words_.Get(index);
}
inline std::string* RecognitionConfig::mutable_additional_words(int index) {
  // @@protoc_insertion_point(field_mutable:Speechpro.Cloud.ASR.RecognitionConfig.additional_words)
  return additional_words_.Mutable(index);
}
inline void RecognitionConfig::set_additional_words(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:Speechpro.Cloud.ASR.RecognitionConfig.additional_words)
  additional_words_.Mutable(index)->assign(value);
}
inline void RecognitionConfig::set_additional_words(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:Speechpro.Cloud.ASR.RecognitionConfig.additional_words)
  additional_words_.Mutable(index)->assign(std::move(value));
}
inline void RecognitionConfig::set_additional_words(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  additional_words_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Speechpro.Cloud.ASR.RecognitionConfig.additional_words)
}
inline void RecognitionConfig::set_additional_words(int index, const char* value, size_t size) {
  additional_words_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Speechpro.Cloud.ASR.RecognitionConfig.additional_words)
}
inline std::string* RecognitionConfig::add_additional_words() {
  // @@protoc_insertion_point(field_add_mutable:Speechpro.Cloud.ASR.RecognitionConfig.additional_words)
  return additional_words_.Add();
}
inline void RecognitionConfig::add_additional_words(const std::string& value) {
  additional_words_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Speechpro.Cloud.ASR.RecognitionConfig.additional_words)
}
inline void RecognitionConfig::add_additional_words(std::string&& value) {
  additional_words_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Speechpro.Cloud.ASR.RecognitionConfig.additional_words)
}
inline void RecognitionConfig::add_additional_words(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  additional_words_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Speechpro.Cloud.ASR.RecognitionConfig.additional_words)
}
inline void RecognitionConfig::add_additional_words(const char* value, size_t size) {
  additional_words_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Speechpro.Cloud.ASR.RecognitionConfig.additional_words)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RecognitionConfig::additional_words() const {
  // @@protoc_insertion_point(field_list:Speechpro.Cloud.ASR.RecognitionConfig.additional_words)
  return additional_words_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RecognitionConfig::mutable_additional_words() {
  // @@protoc_insertion_point(field_mutable_list:Speechpro.Cloud.ASR.RecognitionConfig.additional_words)
  return &additional_words_;
}

// repeated .Speechpro.Cloud.ASR.UserTranscriptions user_transcriptions = 3;
inline int RecognitionConfig::user_transcriptions_size() const {
  return user_transcriptions_.size();
}
inline void RecognitionConfig::clear_user_transcriptions() {
  user_transcriptions_.Clear();
}
inline ::Speechpro::Cloud::ASR::UserTranscriptions* RecognitionConfig::mutable_user_transcriptions(int index) {
  // @@protoc_insertion_point(field_mutable:Speechpro.Cloud.ASR.RecognitionConfig.user_transcriptions)
  return user_transcriptions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Speechpro::Cloud::ASR::UserTranscriptions >*
RecognitionConfig::mutable_user_transcriptions() {
  // @@protoc_insertion_point(field_mutable_list:Speechpro.Cloud.ASR.RecognitionConfig.user_transcriptions)
  return &user_transcriptions_;
}
inline const ::Speechpro::Cloud::ASR::UserTranscriptions& RecognitionConfig::user_transcriptions(int index) const {
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.RecognitionConfig.user_transcriptions)
  return user_transcriptions_.Get(index);
}
inline ::Speechpro::Cloud::ASR::UserTranscriptions* RecognitionConfig::add_user_transcriptions() {
  // @@protoc_insertion_point(field_add:Speechpro.Cloud.ASR.RecognitionConfig.user_transcriptions)
  return user_transcriptions_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Speechpro::Cloud::ASR::UserTranscriptions >&
RecognitionConfig::user_transcriptions() const {
  // @@protoc_insertion_point(field_list:Speechpro.Cloud.ASR.RecognitionConfig.user_transcriptions)
  return user_transcriptions_;
}

// .Speechpro.Cloud.ASR.Auth auth = 4;
inline bool RecognitionConfig::has_auth() const {
  return this != internal_default_instance() && auth_ != nullptr;
}
inline void RecognitionConfig::clear_auth() {
  if (GetArenaNoVirtual() == nullptr && auth_ != nullptr) {
    delete auth_;
  }
  auth_ = nullptr;
}
inline const ::Speechpro::Cloud::ASR::Auth& RecognitionConfig::auth() const {
  const ::Speechpro::Cloud::ASR::Auth* p = auth_;
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.RecognitionConfig.auth)
  return p != nullptr ? *p : *reinterpret_cast<const ::Speechpro::Cloud::ASR::Auth*>(
      &::Speechpro::Cloud::ASR::_Auth_default_instance_);
}
inline ::Speechpro::Cloud::ASR::Auth* RecognitionConfig::release_auth() {
  // @@protoc_insertion_point(field_release:Speechpro.Cloud.ASR.RecognitionConfig.auth)
  
  ::Speechpro::Cloud::ASR::Auth* temp = auth_;
  auth_ = nullptr;
  return temp;
}
inline ::Speechpro::Cloud::ASR::Auth* RecognitionConfig::mutable_auth() {
  
  if (auth_ == nullptr) {
    auto* p = CreateMaybeMessage<::Speechpro::Cloud::ASR::Auth>(GetArenaNoVirtual());
    auth_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Speechpro.Cloud.ASR.RecognitionConfig.auth)
  return auth_;
}
inline void RecognitionConfig::set_allocated_auth(::Speechpro::Cloud::ASR::Auth* auth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete auth_;
  }
  if (auth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      auth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auth, submessage_arena);
    }
    
  } else {
    
  }
  auth_ = auth;
  // @@protoc_insertion_point(field_set_allocated:Speechpro.Cloud.ASR.RecognitionConfig.auth)
}

// -------------------------------------------------------------------

// Auth

// string client_id = 1;
inline void Auth::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Auth::client_id() const {
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.Auth.client_id)
  return client_id_.GetNoArena();
}
inline void Auth::set_client_id(const std::string& value) {
  
  client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Speechpro.Cloud.ASR.Auth.client_id)
}
inline void Auth::set_client_id(std::string&& value) {
  
  client_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Speechpro.Cloud.ASR.Auth.client_id)
}
inline void Auth::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Speechpro.Cloud.ASR.Auth.client_id)
}
inline void Auth::set_client_id(const char* value, size_t size) {
  
  client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Speechpro.Cloud.ASR.Auth.client_id)
}
inline std::string* Auth::mutable_client_id() {
  
  // @@protoc_insertion_point(field_mutable:Speechpro.Cloud.ASR.Auth.client_id)
  return client_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Auth::release_client_id() {
  // @@protoc_insertion_point(field_release:Speechpro.Cloud.ASR.Auth.client_id)
  
  return client_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Auth::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    
  } else {
    
  }
  client_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:Speechpro.Cloud.ASR.Auth.client_id)
}

// string domain_id = 2;
inline void Auth::clear_domain_id() {
  domain_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Auth::domain_id() const {
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.Auth.domain_id)
  return domain_id_.GetNoArena();
}
inline void Auth::set_domain_id(const std::string& value) {
  
  domain_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Speechpro.Cloud.ASR.Auth.domain_id)
}
inline void Auth::set_domain_id(std::string&& value) {
  
  domain_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Speechpro.Cloud.ASR.Auth.domain_id)
}
inline void Auth::set_domain_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  domain_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Speechpro.Cloud.ASR.Auth.domain_id)
}
inline void Auth::set_domain_id(const char* value, size_t size) {
  
  domain_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Speechpro.Cloud.ASR.Auth.domain_id)
}
inline std::string* Auth::mutable_domain_id() {
  
  // @@protoc_insertion_point(field_mutable:Speechpro.Cloud.ASR.Auth.domain_id)
  return domain_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Auth::release_domain_id() {
  // @@protoc_insertion_point(field_release:Speechpro.Cloud.ASR.Auth.domain_id)
  
  return domain_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Auth::set_allocated_domain_id(std::string* domain_id) {
  if (domain_id != nullptr) {
    
  } else {
    
  }
  domain_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), domain_id);
  // @@protoc_insertion_point(field_set_allocated:Speechpro.Cloud.ASR.Auth.domain_id)
}

// string api_key = 3;
inline void Auth::clear_api_key() {
  api_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Auth::api_key() const {
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.Auth.api_key)
  return api_key_.GetNoArena();
}
inline void Auth::set_api_key(const std::string& value) {
  
  api_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Speechpro.Cloud.ASR.Auth.api_key)
}
inline void Auth::set_api_key(std::string&& value) {
  
  api_key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Speechpro.Cloud.ASR.Auth.api_key)
}
inline void Auth::set_api_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  api_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Speechpro.Cloud.ASR.Auth.api_key)
}
inline void Auth::set_api_key(const char* value, size_t size) {
  
  api_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Speechpro.Cloud.ASR.Auth.api_key)
}
inline std::string* Auth::mutable_api_key() {
  
  // @@protoc_insertion_point(field_mutable:Speechpro.Cloud.ASR.Auth.api_key)
  return api_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Auth::release_api_key() {
  // @@protoc_insertion_point(field_release:Speechpro.Cloud.ASR.Auth.api_key)
  
  return api_key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Auth::set_allocated_api_key(std::string* api_key) {
  if (api_key != nullptr) {
    
  } else {
    
  }
  api_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), api_key);
  // @@protoc_insertion_point(field_set_allocated:Speechpro.Cloud.ASR.Auth.api_key)
}

// -------------------------------------------------------------------

// UserTranscriptions

// string word = 1;
inline void UserTranscriptions::clear_word() {
  word_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& UserTranscriptions::word() const {
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.UserTranscriptions.word)
  return word_.GetNoArena();
}
inline void UserTranscriptions::set_word(const std::string& value) {
  
  word_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Speechpro.Cloud.ASR.UserTranscriptions.word)
}
inline void UserTranscriptions::set_word(std::string&& value) {
  
  word_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Speechpro.Cloud.ASR.UserTranscriptions.word)
}
inline void UserTranscriptions::set_word(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  word_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Speechpro.Cloud.ASR.UserTranscriptions.word)
}
inline void UserTranscriptions::set_word(const char* value, size_t size) {
  
  word_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Speechpro.Cloud.ASR.UserTranscriptions.word)
}
inline std::string* UserTranscriptions::mutable_word() {
  
  // @@protoc_insertion_point(field_mutable:Speechpro.Cloud.ASR.UserTranscriptions.word)
  return word_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UserTranscriptions::release_word() {
  // @@protoc_insertion_point(field_release:Speechpro.Cloud.ASR.UserTranscriptions.word)
  
  return word_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UserTranscriptions::set_allocated_word(std::string* word) {
  if (word != nullptr) {
    
  } else {
    
  }
  word_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), word);
  // @@protoc_insertion_point(field_set_allocated:Speechpro.Cloud.ASR.UserTranscriptions.word)
}

// string transcription = 2;
inline void UserTranscriptions::clear_transcription() {
  transcription_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& UserTranscriptions::transcription() const {
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.UserTranscriptions.transcription)
  return transcription_.GetNoArena();
}
inline void UserTranscriptions::set_transcription(const std::string& value) {
  
  transcription_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Speechpro.Cloud.ASR.UserTranscriptions.transcription)
}
inline void UserTranscriptions::set_transcription(std::string&& value) {
  
  transcription_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Speechpro.Cloud.ASR.UserTranscriptions.transcription)
}
inline void UserTranscriptions::set_transcription(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  transcription_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Speechpro.Cloud.ASR.UserTranscriptions.transcription)
}
inline void UserTranscriptions::set_transcription(const char* value, size_t size) {
  
  transcription_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Speechpro.Cloud.ASR.UserTranscriptions.transcription)
}
inline std::string* UserTranscriptions::mutable_transcription() {
  
  // @@protoc_insertion_point(field_mutable:Speechpro.Cloud.ASR.UserTranscriptions.transcription)
  return transcription_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UserTranscriptions::release_transcription() {
  // @@protoc_insertion_point(field_release:Speechpro.Cloud.ASR.UserTranscriptions.transcription)
  
  return transcription_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UserTranscriptions::set_allocated_transcription(std::string* transcription) {
  if (transcription != nullptr) {
    
  } else {
    
  }
  transcription_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transcription);
  // @@protoc_insertion_point(field_set_allocated:Speechpro.Cloud.ASR.UserTranscriptions.transcription)
}

// -------------------------------------------------------------------

// SpeechRecognitionResults

// .Speechpro.Cloud.ASR.Text text = 1;
inline bool SpeechRecognitionResults::has_text() const {
  return this != internal_default_instance() && text_ != nullptr;
}
inline const ::Speechpro::Cloud::ASR::Text& SpeechRecognitionResults::text() const {
  const ::Speechpro::Cloud::ASR::Text* p = text_;
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.SpeechRecognitionResults.text)
  return p != nullptr ? *p : *reinterpret_cast<const ::Speechpro::Cloud::ASR::Text*>(
      &::Speechpro::Cloud::ASR::_Text_default_instance_);
}
inline ::Speechpro::Cloud::ASR::Text* SpeechRecognitionResults::release_text() {
  // @@protoc_insertion_point(field_release:Speechpro.Cloud.ASR.SpeechRecognitionResults.text)
  
  ::Speechpro::Cloud::ASR::Text* temp = text_;
  text_ = nullptr;
  return temp;
}
inline ::Speechpro::Cloud::ASR::Text* SpeechRecognitionResults::mutable_text() {
  
  if (text_ == nullptr) {
    auto* p = CreateMaybeMessage<::Speechpro::Cloud::ASR::Text>(GetArenaNoVirtual());
    text_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Speechpro.Cloud.ASR.SpeechRecognitionResults.text)
  return text_;
}
inline void SpeechRecognitionResults::set_allocated_text(::Speechpro::Cloud::ASR::Text* text) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_);
  }
  if (text) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      text = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text, submessage_arena);
    }
    
  } else {
    
  }
  text_ = text;
  // @@protoc_insertion_point(field_set_allocated:Speechpro.Cloud.ASR.SpeechRecognitionResults.text)
}

// float phrase_confidence = 2;
inline void SpeechRecognitionResults::clear_phrase_confidence() {
  phrase_confidence_ = 0;
}
inline float SpeechRecognitionResults::phrase_confidence() const {
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.SpeechRecognitionResults.phrase_confidence)
  return phrase_confidence_;
}
inline void SpeechRecognitionResults::set_phrase_confidence(float value) {
  
  phrase_confidence_ = value;
  // @@protoc_insertion_point(field_set:Speechpro.Cloud.ASR.SpeechRecognitionResults.phrase_confidence)
}

// bool is_final = 3;
inline void SpeechRecognitionResults::clear_is_final() {
  is_final_ = false;
}
inline bool SpeechRecognitionResults::is_final() const {
  // @@protoc_insertion_point(field_get:Speechpro.Cloud.ASR.SpeechRecognitionResults.is_final)
  return is_final_;
}
inline void SpeechRecognitionResults::set_is_final(bool value) {
  
  is_final_ = value;
  // @@protoc_insertion_point(field_set:Speechpro.Cloud.ASR.SpeechRecognitionResults.is_final)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ASR
}  // namespace Cloud
}  // namespace Speechpro

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_AsrService_2eproto
